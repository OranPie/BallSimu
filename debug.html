<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>球体战争 - 配置版</title>
    <style>
        body {
            background-color: #f0f0f0;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        #game {
            border: 2px solid #333;
            background-color: #000;
        }
        #config {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ccc;
            background-color: #fff;
            width: 400px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #config label {
            display: block;
            margin-bottom: 10px;
        }
        #config input, #config select {
            width: 100%;
            padding: 5px;
        }
        #config button {
            width: 100%;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        #config button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
<canvas id="game" width="1200" height="800"></canvas>
<div id="config">
    <label>随机事件最小帧间隔: <input id="event_min_frames" type="number" value="100"></label>
    <label>随机事件触发概率: <input id="event_prob" type="number" step="0.01" value="0.1"></label>
    <label>奖励等级 (逗号分隔): <input id="rewards" value="15000,150000,300000,600000,1200000,2400000,5000000"></label>
    <label>奖励权重 (逗号分隔): <input id="weights" value="0.5,0.2,0.2,0.05,0.03,0.01,0.01"></label>
    <label>队伍数量:
        <select id="team_count">
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4" selected>4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10">10</option>
            
        </select>
    </label>
    <button onclick="applyConfig()">应用配置并重启游戏</button>
</div>
<script>
    // Constants and helper functions
    const SCREEN_WIDTH = 1200;
    const SCREEN_HEIGHT = 800;
    const BACKGROUND = [20, 20, 30];
    const NEUTRAL_COLOR = [100, 100, 120];
    const RED = [255, 80, 80];
    const GREEN = [80, 255, 100];
    const BLUE = [80, 150, 255];
    const YELLOW = [255, 255, 80];
    const PURPLE = [200, 80, 255];
    const CYAN = [80, 220, 220];
    const ORANGE = [255, 180, 80];
    const PINK = [255, 100, 180];
    const TEAL = [80, 200, 180];
    const BROWN = [180, 120, 80];
    const BulletType = Object.freeze({
        NORMAL: 1,
        SPREADING: 2,
        ROTATING: 3,
        SHOT: 4,
        LASER: 6,
        SPLITTING: 8
    });
    const BallType = Object.freeze({
        NORMAL: 1,
        FASTER: 2,
        STRESSED: 3
    });
    const TURRET_ANGLE_SPEED = 0.4;
    const BULLET_SPEED = 0.003 * SCREEN_WIDTH;
    const BASE_BALL_SPEED = 0.005 * SCREEN_WIDTH;
    const SINGLE_BLOCK_WIDTH = 0.0005 * SCREEN_WIDTH;
    const TERRITORY_CLAIM_COST = [1, 2];
    const CLEAR_MAP_FRAME = -1;
    const BASE_SHIELD = 2000000;
    const ATTRACTION_RADIUS = 0.4 * SCREEN_WIDTH;
    const TURRET_LENGTH = 0.01 * SCREEN_WIDTH;
    const BASE_ATTACK_RADIUS = 0.05 * SCREEN_WIDTH;
    const INITIAL_BULLETS = 100000;
    const BULLET_CLAIM_STEP = 7;
    const BALL_CLAIM_STEP = 18;
    let TICKING = 60;
    const REVIVAL_TIME = 60000;
    const REVIVAL_COST = 1000000;
    const LASER_DURATION = 120;
    const SPLITTING_TIME = 1000;
    const SPLITTING_COUNT = 3;
    const BALANCE_ADJUSTMENTS = {
        [BulletType.NORMAL]: { cost_factor: 1.0, value_factor: 1.0 },
        [BulletType.SPREADING]: { cost_factor: 0.7, value_factor: 0.5 },
        [BulletType.ROTATING]: { cost_factor: 1.2, value_factor: 1.5 },
        [BulletType.SHOT]: { cost_factor: 0.9, value_factor: 0.8 },
        [BulletType.LASER]: { cost_factor: 1.8, value_factor: 3.0 },
        [BulletType.SPLITTING]: { cost_factor: 1.3, value_factor: 1.2 }
    };
    const FONT = '24px sans-serif';
    const LARGE_FONT = '36px sans-serif';
    const SMALL_FONT = '18px sans-serif';

    // Configurable elements
    let config = {
        event_min_frames: 100,
        event_prob: 0.1,
        event_rewards: [15000, 150000, 300000, 600000, 1200000, 2400000, 5000000],
        reward_weights: [0.5, 0.2, 0.2, 0.05, 0.03, 0.01, 0.01],
        team_count: 4
    };

    function getTeamDefs(count) {
        const colors = [RED, BLUE, GREEN, YELLOW, PURPLE, CYAN, ORANGE, PINK, TEAL, BROWN];
        const names = ["RED", "BLUE", "GREEN", "YELLOW", "PURPLE", "CYAN", "ORANGE", "PINK", "TEAL", "BROWN"];
        let positions = [];
        if (count === 2) {
            positions = [[0.25, 0.5], [0.75, 0.5]];
        } else if (count === 3) {
            positions = [[0.5, 0.25], [0.25, 0.75], [0.75, 0.75]];
        } else if (count === 4) {
            positions = [[0.08, 0.08], [0.92, 0.08], [0.08, 0.92], [0.92, 0.92]];
        } else {
            for (let i = 0; i < count; i++) {
                const angle = i * 2 * Math.PI / count;
                const r = 0.4;
                positions.push([0.5 + r * Math.cos(angle), 0.5 + r * Math.sin(angle)]);
            }
        }
        return positions.map((pos, i) => [names[i % names.length], pos, colors[i % colors.length]]);
    }

    // Helper functions
    function rgb(color) {
        return `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
    }
    function rgba(color, alpha) {
        return `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})`;
    }
    function get_collide_result(m1, m2, s1, s2, a1, a2) {
        const a1_rad = a1 * Math.PI / 180;
        const a2_rad = a2 * Math.PI / 180;
        const v1i = [s1 * Math.cos(a1_rad), s1 * Math.sin(a1_rad)];
        const v2i = [s2 * Math.cos(a2_rad), s2 * Math.sin(a2_rad)];
        const r1 = [1, 0];
        const r2 = [0, 0];
        let n = [r2[0] - r1[0], r2[1] - r1[1]];
        const norm = Math.sqrt(n[0]**2 + n[1]**2);
        n = [n[0] / norm, n[1] / norm];
        const v1n = v1i[0] * n[0] + v1i[1] * n[1];
        const v2n = v2i[0] * n[0] + v2i[1] * n[1];
        const total_mass = m1 + m2;
        const v1n_new = (v1n * (m1 - m2) + 2 * m2 * v2n) / total_mass;
        const v2n_new = (v2n * (m2 - m1) + 2 * m1 * v1n) / total_mass;
        const t = [-n[1], n[0]];
        const v1t = v1i[0] * t[0] + v1i[1] * t[1];
        const v2t = v2i[0] * t[0] + v2i[1] * t[1];
        const v1f = [v1n_new * n[0] + v1t * t[0], v1n_new * n[1] + v1t * t[1]];
        const v2f = [v2n_new * n[0] + v2t * t[0], v2n_new * n[1] + v2t * t[1]];
        const s1_new = Math.sqrt(v1f[0]**2 + v1f[1]**2);
        const s2_new = Math.sqrt(v2f[0]**2 + v2f[1]**2);
        let a1_new = (Math.atan2(v1f[1], v1f[0]) * 180 / Math.PI) % 360;
        if (a1_new < 0) a1_new += 360;
        let a2_new = (Math.atan2(v2f[1], v2f[0]) * 180 / Math.PI) % 360;
        if (a2_new < 0) a2_new += 360;
        return [s1_new, s2_new, a1_new, a2_new];
    }
    function weighted_random(num, weights) {
        let total = 0;
        const cumulative = weights.map(w => total += w);
        const rand = Math.random() * total;
        for (let i = 0; i < num; i++) {
            if (rand < cumulative[i]) return i;
        }
        return num - 1;
    }
    // Classes
    class Profiler {
        constructor() {
            this.data = {};
            this.current_section = null;
            this.start_time = 0;
            this.frame_times = [];
        }
        start_section(name) {
            if (this.current_section) this.end_section();
            this.current_section = name;
            this.start_time = performance.now();
        }
        end_section() {
            if (!this.current_section) return;
            const end_time = performance.now();
            const duration = end_time - this.start_time;
            if (!(this.current_section in this.data)) {
                this.data[this.current_section] = { total: 0, count: 0, max: 0, min: Infinity };
            }
            const section = this.data[this.current_section];
            section.total += duration;
            section.count += 1;
            section.max = Math.max(section.max, duration);
            section.min = Math.min(section.min, duration);
            this.current_section = null;
        }
        frame_end() {
            this.end_section();
            this.frame_times.push(performance.now());
            if (this.frame_times.length > 100) this.frame_times.shift();
        }
        get_fps() {
            if (this.frame_times.length < 2) return [0, 0];
            const len = this.frame_times.length;
            const total_time = this.frame_times[len - 1] - this.frame_times[0];
            const last_duration = this.frame_times[len - 1] - this.frame_times[len - 2];
            return [len / total_time, last_duration];
        }
        get_stats() {
            const stats = [];
            for (let name in this.data) {
                const data = this.data[name];
                if (data.count > 0) {
                    const avg = data.total / data.count;
                    stats.push([
                        name,
                        `avg: ${avg.toFixed(3)}ms`,
                        `min: ${data.min.toFixed(3)}ms`,
                        `max: ${data.max.toFixed(3)}ms`
                    ]);
                }
            }
            return stats;
        }
    }
    class DamageText {
        constructor(pos, damage, color) {
            this.pos = [...pos];
            this.text = `-${damage}`;
            this.color = color;
            this.lifetime = 60;
            this.original_lifetime = 60;
        }
        update() {
            this.pos[1] -= 1;
            this.lifetime -= 1;
            return this.lifetime <= 0;
        }
        draw(ctx) {
            const alpha = 255 * (this.lifetime / this.original_lifetime);
            ctx.font = SMALL_FONT;
            ctx.fillStyle = rgba(this.color, alpha / 255);
            const width = ctx.measureText(this.text).width;
            ctx.fillText(this.text, this.pos[0] - width / 2, this.pos[1]);
        }
    }
    class Entity {
        constructor(team, pos, angle = Math.random() * 360) {
            this.team = team;
            this.pos = [...pos];
            this.angle = angle;
            this.trail = [];
            this.last_pos = [...pos];
            this.value = 0;
            this.radius = 0;
            this.speed = 0;
            this.base_speed = 0;
            this.type = null;
            this.active = true;
            this.collision_cooldown = 0;
        }
        update(game) {}
        draw(ctx) {}
        calculate_radius() {
            return 0;
        }
        handle_border_collision() {
            if (this.pos[0] - this.radius <= 0) {
                this.pos[0] = this.radius + 1;
                this.angle = 180 - this.angle;
            } else if (this.pos[0] + this.radius >= SCREEN_WIDTH) {
                this.pos[0] = SCREEN_WIDTH - this.radius - 1;
                this.angle = 180 - this.angle;
            }
            if (this.pos[1] - this.radius <= 0) {
                this.pos[1] = this.radius + 1;
                this.angle = -this.angle;
            } else if (this.pos[1] + this.radius >= SCREEN_HEIGHT) {
                this.pos[1] = SCREEN_HEIGHT - this.radius - 1;
                this.angle = -this.angle;
            }
        }
        move(game) {
            this.last_pos = [...this.pos];
            this.trail.push([Math.floor(this.pos[0]), Math.floor(this.pos[1])]);
            if (this.trail.length > 5) this.trail.shift();
            let speed_multiplier = 1.0;
            const owner = game.get_territory_owner(this.pos);
            if (owner === null) speed_multiplier = 0.8;
            else if (owner === this.team) speed_multiplier = 1.5;
            else speed_multiplier = 0.5;
            const dx = this.base_speed * speed_multiplier * Math.cos(this.angle * Math.PI / 180);
            const dy = this.base_speed * speed_multiplier * Math.sin(this.angle * Math.PI / 180);
            this.pos[0] += dx;
            this.pos[1] += dy;
        }
        claim_territory(game, step_size) {
            return game.claim_territory_along_line(this.last_pos, this.pos, this.team, step_size);
        }
        _collide(other) {
            const radius = this.radius + other.radius;
            const dx = this.pos[0] - other.pos[0];
            const dy = this.pos[1] - other.pos[1];
            return Math.sqrt(dx * dx + dy * dy) < radius;
        }
        handle_collision_with_ball(ball, game) {
            if (this.collision_cooldown > 0 || ball.collision_cooldown > 0) return false;
            if (!this._collide(ball)) return false;
            if (ball.team === this.team) {
                return false;
            }
            const ratio = this.value / ball.value;
            if (ratio === 0) return false;
            let [s1, s2, a1, a2] = get_collide_result(this.value, ball.value, this.speed, ball.speed, this.angle, ball.angle);
            this.speed = s1;
            ball.speed = s2;
            this.angle = a1;
            ball.angle = a2;
            if (0.1 <= ratio && ratio <= 10) {
                const self_loss = ball.value * 0.5;
                const ball_loss = this.value * 0.5;
                if (self_loss > 0) game.damage_texts.push(new DamageText(this.pos, Math.floor(self_loss), [255, 50, 50]));
                if (ball_loss > 0) game.damage_texts.push(new DamageText(ball.pos, Math.floor(ball_loss), [255, 50, 50]));
                this.value = Math.max(0, this.value - self_loss);
                ball.value = Math.max(0, ball.value - ball_loss);
            } else {
                if (ratio < 0.1) {
                    ball.value -= this.value;
                    game.damage_texts.push(new DamageText(this.pos, Math.floor(this.value), [255, 50, 50]));
                    this.value = 0;
                } else if (ratio > 10) {
                    this.value -= ball.value;
                    game.damage_texts.push(new DamageText(ball.pos, Math.floor(ball.value), [255, 50, 50]));
                    ball.value = 0;
                }
            }
            this.radius = this.calculate_radius();
            ball.radius = ball.calculate_radius();
            return true;
        }
        handle_collision_with_base(base, game) {
            const dx = this.pos[0] - base.pos[0];
            const dy = this.pos[1] - base.pos[1];
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (base.team === this.team) {
                return false;
            }
            if (dist < BASE_ATTACK_RADIUS) {
                let damage = 0;
                if (this.value >= base.shield * 10) {
                    damage = base.shield;
                    base.shield = 0;
                    this.value = 0;
                } else {
                    damage = this.value;
                    base.shield -= this.value;
                    this.value = 0;
                }
                game.damage_texts.push(new DamageText(base.pos, Math.floor(damage), [255, 100, 100]));
                if (base.shield <= 0) {
                    base.active = false;
                    base.shield = 0;
                    base.death_time = performance.now();
                    game.show_message(`${base.name} 已被淘汰!`);
                }
                return true;
            }
            return false;
        }
    }
    class TeamBase extends Entity {
        constructor(name, rel_pos, color) {
            const pos = [rel_pos[0] * SCREEN_WIDTH, rel_pos[1] * SCREEN_HEIGHT];
            super(name, pos);
            this.name = name;
            this.color = color;
            this.advance = 1;
            this.bullets = [];
            this.bullets.push([INITIAL_BULLETS, BulletType.ROTATING, 1]);
            this.shield = BASE_SHIELD;
            this.active = true;
            this.territory = 0;
            this.target_lock = false;
            this.firing = false;
            this.current_bullet = null;
            this.fire_start_time = 0;
            this.fire_duration = 0;
            this.radius = 25;
            this.death_time = 0;
            this.reviving = false;
            this.continuous_fire_time = 0;
            this.last_fire_time = 0;
            this.shooting_rate = 0;
            this.total_bullets = INITIAL_BULLETS;
        }
        add_bullets(amount, type = BulletType.ROTATING, val = 1) {
            const adjustments = BALANCE_ADJUSTMENTS[type] || { cost_factor: 1.0, value_factor: 1.0 };
            const adjusted_amount = Math.floor(amount * adjustments.cost_factor);
            const adjusted_val = Math.ceil(val * adjustments.value_factor);
            this.bullets.push([adjusted_amount, type, adjusted_val]);
            this.total_bullets += adjusted_amount * adjusted_val;
        }
        update_turret(enemies) {
            this.target_lock = false;
            if (this.firing && this.current_bullet && this.current_bullet[1] === BulletType.ROTATING) {
                this.angle = (this.angle + TURRET_ANGLE_SPEED) % 360;
                return;
            }
            if (!this.active || enemies.length === 0) {
                this.angle = (this.angle + TURRET_ANGLE_SPEED) % 360;
                return;
            }
            let closest_enemy = null;
            let min_dist = Infinity;
            let close_enemy = null;
            for (let enemy of enemies) {
                const dx = enemy.pos[0] - this.pos[0];
                const dy = enemy.pos[1] - this.pos[1];
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 0.12 * SCREEN_WIDTH) {
                    if (dist < min_dist) {
                        min_dist = dist;
                        close_enemy = enemy;
                    }
                } else if (dist < min_dist && dist < ATTRACTION_RADIUS) {
                    min_dist = dist;
                    closest_enemy = enemy;
                }
            }
            const target = close_enemy || closest_enemy;
            if (target) {
                const dx = target.pos[0] - this.pos[0];
                const dy = target.pos[1] - this.pos[1];
                this.angle = Math.atan2(dy, dx) * 180 / Math.PI;
                this.target_lock = true;
            } else {
                this.angle = (this.angle + TURRET_ANGLE_SPEED) % 360;
            }
        }
        fire_from_queue() {
            if (!this.active || (this.bullets.length === 0 && !this.current_bullet)) {
                this.firing = false;
                return [];
            }
            const current_time = performance.now();
            if (!this.firing) {
                this.firing = true;
                this.fire_start_time = current_time;
                this.last_fire_time = current_time;
                this.current_bullet = this.bullets.shift();
            }
            if (this.firing) {
                this.continuous_fire_time += current_time - this.last_fire_time;
                this.last_fire_time = current_time;
            }
            if (this.current_bullet && this.current_bullet[0] > 0) {
                const log_val = Math.log2(this.bullets.reduce((sum, q) => sum + q[0], 0));
                this.shooting_rate = Math.max(1, Math.min(30, log_val / 3));
            }
            const continuous_bonus = Math.min(2.0, 1.0 + (this.continuous_fire_time / 30000) * 0.05);
            if (this.continuous_fire_time > (2500 * (this.advance || 1)) && this.current_bullet[0] > 500) {
                this.current_bullet[0] = Math.floor(this.current_bullet[0] / 2);
                this.current_bullet[2] *= 2;
                this.advance = (this.advance || 1) + 1;
            }
            const [amount, bullet_type, value] = this.current_bullet || [0, null, 0];
            if (amount <= 0) {
                this.firing = false;
                this.current_bullet = null;
                this.continuous_fire_time = 0;
                this.shooting_rate = 0;
                this.advance = 0;
                return [];
            }
            let fire_amount;
            if (bullet_type === BulletType.SHOT) {
                fire_amount = Math.min(amount, Math.floor(20 * this.shooting_rate * continuous_bonus));
                const bullets = this.fire_shot_bullets(fire_amount, value * 10);
                this.current_bullet[0] = Math.max(0, amount - fire_amount * 10);
                return bullets;
            } else if (bullet_type === BulletType.LASER) {
                if (amount > 0) {
                    this.current_bullet[0] = amount - 1;
                    return [this.fire_laser_bullet(value)];
                }
            } else if (bullet_type === BulletType.SPLITTING) {
                fire_amount = Math.min(amount, Math.floor(10 * this.shooting_rate * continuous_bonus));
                const bullets = this.fire_splitting_bullets(fire_amount, value);
                this.current_bullet[0] = amount - fire_amount;
                return bullets;
            } else {
                fire_amount = Math.min(amount, Math.floor(this.shooting_rate * continuous_bonus));
                this.current_bullet[0] = amount - fire_amount;
                if (bullet_type === BulletType.NORMAL) {
                    return Array.from({length: fire_amount}, () => this.fire_bullet(bullet_type, 1, value));
                } else if (bullet_type === BulletType.SPREADING) {
                    return this.fire_spreading_bullets(fire_amount, value);
                } else if (bullet_type === BulletType.ROTATING) {
                    return this.fire_rotating_bullets(fire_amount, value);
                }
            }
            return [];
        }
        fire_shot_bullets(amount, value) {
            const bullets = [];
            const spread_count = Math.min(amount, 10);
            const base_angle = this.angle - 30;
            const angle_step = spread_count > 1 ? 60 / (spread_count - 1) : 0;
            for (let i = 0; i < spread_count; i++) {
                const angle = base_angle + i * angle_step;
                const end_x = this.pos[0] + TURRET_LENGTH * Math.cos(angle * Math.PI / 180);
                const end_y = this.pos[1] + TURRET_LENGTH * Math.sin(angle * Math.PI / 180);
                bullets.push(new Bullet(this, BulletType.SHOT, value, [end_x, end_y], angle));
            }
            return bullets;
        }
        fire_laser_bullet(value) {
            const end_x = this.pos[0] + TURRET_LENGTH * Math.cos(this.angle * Math.PI / 180);
            const end_y = this.pos[1] + TURRET_LENGTH * Math.sin(this.angle * Math.PI / 180);
            return new Bullet(this, BulletType.LASER, value, [end_x, end_y], this.angle);
        }
        fire_splitting_bullets(amount, value) {
            const bullets = [];
            for (let i = 0; i < amount; i++) {
                const angle = this.angle + (Math.random() * 20 - 10);
                const end_x = this.pos[0] + TURRET_LENGTH * Math.cos(angle * Math.PI / 180);
                const end_y = this.pos[1] + TURRET_LENGTH * Math.sin(angle * Math.PI / 180);
                bullets.push(new Bullet(this, BulletType.SPLITTING, value, [end_x, end_y], angle));
            }
            return bullets;
        }
        fire_bullet(bullet_type, amount, value) {
            const end_x = this.pos[0] + TURRET_LENGTH * Math.cos(this.angle * Math.PI / 180);
            const end_y = this.pos[1] + TURRET_LENGTH * Math.sin(this.angle * Math.PI / 180);
            return new Bullet(this, bullet_type, value, [end_x, end_y], this.angle);
        }
        fire_spreading_bullets(amount, value) {
            const bullets = [];
            const spread_count = Math.min(amount, 20);
            for (let i = 0; i < spread_count; i++) {
                const angle = this.angle + (Math.random() * 60 - 30);
                const end_x = this.pos[0] + TURRET_LENGTH * Math.cos(angle * Math.PI / 180);
                const end_y = this.pos[1] + TURRET_LENGTH * Math.sin(angle * Math.PI / 180);
                bullets.push(new Bullet(this, BulletType.SPREADING, value, [end_x, end_y], angle));
            }
            return bullets;
        }
        fire_rotating_bullets(amount, value) {
            const bullets = [];
            const rotation_count = Math.min(amount, 36);
            for (let i = 0; i < rotation_count; i++) {
                const angle = this.angle + i * (360 / rotation_count);
                const end_x = this.pos[0] + TURRET_LENGTH * Math.cos(angle * Math.PI / 180);
                const end_y = this.pos[1] + TURRET_LENGTH * Math.sin(angle * Math.PI / 180);
                bullets.push(new Bullet(this, BulletType.ROTATING, value, [end_x, end_y], angle));
            }
            return bullets;
        }
        draw(ctx) {
            ctx.beginPath();
            ctx.arc(this.pos[0], this.pos[1], this.radius, 0, Math.PI * 2);
            ctx.fillStyle = rgb(this.color);
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = rgb([50, 50, 50]);
            ctx.stroke();
            const end_x = this.pos[0] + TURRET_LENGTH * Math.cos(this.angle * Math.PI / 180);
            const end_y = this.pos[1] + TURRET_LENGTH * Math.sin(this.angle * Math.PI / 180);
            ctx.beginPath();
            ctx.moveTo(this.pos[0], this.pos[1]);
            ctx.lineTo(end_x, end_y);
            ctx.lineWidth = 6;
            ctx.strokeStyle = rgb([200, 200, 200]);
            ctx.stroke();
            this.draw_bullet_queue(ctx);
            ctx.font = FONT;
            ctx.fillStyle = 'rgb(255,255,255)';
            ctx.textAlign = 'center';
            const shield_text = `护盾: ${this.format_value(this.shield)}`;
            const text_width = ctx.measureText(shield_text).width;
            ctx.fillText(shield_text, this.pos[0] - text_width / 2, this.pos[1] + 30);
            const shield_percent = Math.min(1.0, this.shield / BASE_SHIELD);
            ctx.fillStyle = rgb([100, 100, 100]);
            ctx.fillRect(this.pos[0] - 40, this.pos[1] + 60, 80, 10);
            ctx.fillStyle = rgb(this.color);
            ctx.fillRect(this.pos[0] - 40, this.pos[1] + 60, 80 * shield_percent, 10);
            ctx.fillStyle = 'rgb(200,200,200)';
            if (this.target_lock) {
                ctx.beginPath();
                ctx.arc(this.pos[0], this.pos[1], 30, 0, Math.PI * 2);
                ctx.lineWidth = 3;
                ctx.strokeStyle = 'rgb(255,255,0)';
                ctx.stroke();
            }
            if (this.firing) {
                ctx.font = SMALL_FONT;
                ctx.fillStyle = 'rgb(200,255,200)';
                const rate_text = `射击速率: ${this.shooting_rate.toFixed(1)}x`;
                const rate_width = ctx.measureText(rate_text).width;
                ctx.fillText(rate_text, this.pos[0] - rate_width / 2, this.pos[1] - 100);
            }
            if (!this.active && this.death_time > 0) {
                const time_left = Math.max(0, Math.floor((this.death_time + REVIVAL_TIME - performance.now()) / 1000));
                const revive_text = `复活倒计时: ${time_left}s`;
                const revive_width = ctx.measureText(revive_text).width;
                ctx.fillStyle = 'rgb(200,200,100)';
                ctx.fillText(revive_text, this.pos[0] - revive_width / 2, this.pos[1] - 120);
            }
        }
        draw_bullet_queue(ctx) {
            ctx.font = FONT;
            ctx.fillStyle = 'rgb(255,255,255)';
            const total_bullets = this.bullets.reduce((sum, q) => sum + q[0], 0);
            const queue_text = `子弹队列: ${total_bullets}`;
            const queue_width = ctx.measureText(queue_text).width;
            ctx.fillText(queue_text, this.pos[0] - queue_width / 2, this.pos[1] - 50);
            let start_y = this.pos[1] > 400 ? this.pos[1] - 80 : this.pos[1] + 140;
            const dir = this.pos[1] > 400 ? -30 : 30;
            const max_display = 2;
            let displayed = 0;
            if (this.firing && this.current_bullet) {
                const [amount, bullet_type, value] = this.current_bullet;
                this.draw_bullet_info(ctx, this.pos[0], start_y, amount, bullet_type, value, true);
                start_y += dir;
                displayed += 1;
            }
            for (let i = 0; i < Math.min(this.bullets.length, max_display - displayed); i++) {
                const [amount, bullet_type, value] = this.bullets[i];
                this.draw_bullet_info(ctx, this.pos[0], start_y + i * dir, amount, bullet_type, value);
                displayed += 1;
            }
            if (this.bullets.length > max_display) {
                const more_text = `...还有${this.bullets.length - max_display}个`;
                const more_width = ctx.measureText(more_text).width;
                ctx.fillStyle = 'rgb(150,150,150)';
                ctx.fillText(more_text, this.pos[0] - more_width / 2, start_y + (displayed) * dir);
            }
        }
        draw_bullet_info(ctx, x, y, amount, bullet_type, value, is_current = false) {
            const color_map = {
                [BulletType.NORMAL]: [200, 200, 200],
                [BulletType.SPREADING]: [100, 255, 100],
                [BulletType.ROTATING]: [100, 100, 255],
                [BulletType.SHOT]: [255, 100, 255],
                [BulletType.LASER]: [255, 50, 50],
                [BulletType.SPLITTING]: [255, 150, 50]
            };
            const name_map = {
                [BulletType.NORMAL]: "普通",
                [BulletType.SPREADING]: "散射",
                [BulletType.ROTATING]: "旋转",
                [BulletType.SHOT]: "扇形",
                [BulletType.LASER]: "激光",
                [BulletType.SPLITTING]: "分裂"
            };
            let color = color_map[bullet_type] || [200, 200, 200];
            const type_name = name_map[bullet_type] || "未知";
            if (is_current) {
                ctx.fillStyle = 'rgb(50,50,80)';
                ctx.fillRect(x - 100, y - 15, 200, 25);
                color = [Math.min(255, color[0] + 50), Math.min(255, color[1] + 50), Math.min(255, color[2] + 50)];
            }
            ctx.beginPath();
            ctx.arc(x - 80, y, 8, 0, Math.PI * 2);
            ctx.fillStyle = rgb(color);
            ctx.fill();
            ctx.font = FONT;
            ctx.fillStyle = rgb(color);
            const info_text = `${type_name} ×${amount} (v=${this.format_value(value)})`;
            ctx.textBaseline = 'middle';
            ctx.fillText(info_text, x - 60, y);
        }
        format_value(value) {
            if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;
            if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;
            return value.toString();
        }
        try_revive(bullet_value) {
            if (!this.active && bullet_value >= REVIVAL_COST) {
                const shield_created = bullet_value * 0.01;
                this.shield = Math.min(BASE_SHIELD, shield_created);
                const ammo_refilled = bullet_value * 0.1;
                this.add_bullets(Math.floor(ammo_refilled / 1000), BulletType.NORMAL, Math.floor(ammo_refilled / 10000));
                this.active = true;
                this.reviving = false;
                const game_minutes = Math.floor(performance.now() / 60000);
                const extra_balls = Math.min(10, 2 + Math.floor(game_minutes / 3));
                return [extra_balls, bullet_value];
            }
            return [0, 0];
        }
    }
    class Bullet extends Entity {
        constructor(team, bullet_type, value, pos, angle) {
            super(team.name, pos, angle);
            this.type = bullet_type;
            this.value = value;
            this.base_speed = BULLET_SPEED;
            this.laser_timer = bullet_type === BulletType.LASER ? LASER_DURATION : 0;
            this.split_timer = bullet_type === BulletType.SPLITTING ? SPLITTING_TIME : 0;
            if (bullet_type === BulletType.SHOT) this.radius = 4;
            else if (bullet_type === BulletType.LASER) this.radius = 15;
            else if (bullet_type === BulletType.NORMAL) this.radius = 3;
            else this.radius = 2;
            this.creation_time = performance.now();
            this.last_territory_claim = performance.now();
            this.lifetime = 20000;
            this.trail = [];
            this.last_pos = [...pos];
        }
        update(game) {
            this.move(game);
            this.handle_border_collision();
            const cost = this.claim_territory(game, BULLET_CLAIM_STEP);
            this.value = Math.max(0, this.value - cost);
            if (this.type === BulletType.LASER) {
                this.laser_timer -= 1;
                if (this.laser_timer <= 0) this.value = 0;
            }
            if (this.type === BulletType.SPLITTING) {
                const current_time = performance.now();
                if (current_time - this.creation_time > this.split_timer && this.value > 0) {
                    this.split = true;
                }
            }
        }
        should_remove() {
            return this.value <= 0;
        }
        draw(ctx) {
            let team_obj = null;
            for (let i = 0; i < game.teams.length; i++) {
                if (game.teams[i].name === this.team) {
                    team_obj = game.teams[i];
                    break;
                }
            }
            if (team_obj === null) {
                return;
            }
            let color = [...team_obj.color];
            if (this.type === BulletType.SPREADING) color = [color[0] / 2, color[1], color[2] / 2];
            else if (this.type === BulletType.ROTATING) color = [color[0], color[1] / 2, color[2]];
            else if (this.type === BulletType.SHOT) color = [color[0], color[1], color[0]];
            else if (this.type === BulletType.LASER) color = [Math.min(255, color[0] + 100), Math.max(0, color[1] - 50), Math.max(0, color[2] - 50)];
            else if (this.type === BulletType.SPLITTING) color = [Math.min(255, color[0] + 50), Math.min(255, color[1] + 50), Math.max(0, color[2] - 50)];
            ctx.beginPath();
            ctx.arc(this.pos[0], this.pos[1], this.radius + 1, 0, Math.PI * 2);
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgb(255,255,255)';
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(this.pos[0], this.pos[1], this.radius, 0, Math.PI * 2);
            ctx.fillStyle = rgb(color);
            ctx.fill();
            if (this.type === BulletType.LASER) {
                const laser_length = 100;
                const end_x = this.pos[0] + laser_length * Math.cos(this.angle * Math.PI / 180);
                const end_y = this.pos[1] + laser_length * Math.sin(this.angle * Math.PI / 180);
                ctx.beginPath();
                ctx.moveTo(this.pos[0], this.pos[1]);
                ctx.lineTo(end_x, end_y);
                ctx.lineWidth = 5;
                ctx.strokeStyle = 'rgb(255,100,100)';
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(this.pos[0], this.pos[1], this.radius * 0.8, 0, Math.PI * 2);
                ctx.fillStyle = 'rgb(255,255,200)';
                ctx.fill();
            } else if (this.type === BulletType.SPLITTING) {
                ctx.beginPath();
                ctx.arc(this.pos[0], this.pos[1], this.radius * 1.2, 0, Math.PI * 2);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgb(255,200,100)';
                ctx.stroke();
                if (this.split_timer > 0) {
                    const time_left = (this.split_timer - (performance.now() - this.creation_time)) / this.split_timer;
                    const angle = 360 * time_left;
                    ctx.beginPath();
                    ctx.arc(this.pos[0], this.pos[1], this.radius * 1.5, 0, angle * Math.PI / 180);
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = 'rgb(255,150,50)';
                    ctx.stroke();
                }
            }
        }
    }
    class Ball extends Entity {
        constructor(team, ball_type, value, pos, angle = null) {
            super(team.name, pos, angle);
            this.type = ball_type;
            this.value = value;
            this.radius = this.calculate_radius();
            this.base_speed = this.calculate_base_speed();
            this.speed = this.base_speed;
        }
        calculate_radius() {
            return Math.max(5, Math.min(50, Math.log(this.value + 1) * 2));
        }
        calculate_base_speed() {
            let base_speed = BASE_BALL_SPEED;
            if (this.type === BallType.FASTER) base_speed *= 1.5;
            else if (this.type === BallType.STRESSED) base_speed *= 0.7;
            const speed_factor = 1.0 / (1 + Math.log(this.value + 1) * 0.05);
            return base_speed * speed_factor;
        }
        update(game) {
            this.radius = this.calculate_radius();
            this.base_speed = this.calculate_base_speed();
            this.move(game);
            this.handle_border_collision();
            const cost = this.claim_territory(game, this.radius);
            this.value = Math.max(0, this.value - cost);
            if (this.collision_cooldown > 0) this.collision_cooldown -= 1;
        }
        draw(ctx) {
            for (let i = 0; i < this.trail.length; i++) {
                const pos = this.trail[i];
                const alpha = Math.floor(200 * (i / this.trail.length));
                ctx.beginPath();
                ctx.arc(pos[0], pos[1], Math.max(1, Math.floor(this.radius * 0.3)), 0, Math.PI * 2);
                let team_obj = null;
                for (let i = 0; i < game.teams.length; i++) {
                    if (game.teams[i].name === this.team) {
                        team_obj = game.teams[i];
                        break;
                    }
                }
                ctx.fillStyle = rgba(team_obj.color, alpha / 255);
                ctx.fill();
            }
            ctx.beginPath();
            ctx.arc(this.pos[0], this.pos[1], this.radius, 0, Math.PI * 2);
            let team_obj = null;
            for (let i = 0; i < game.teams.length; i++) {
                if (game.teams[i].name === this.team) {
                    team_obj = game.teams[i];
                    break;
                }
            }
            ctx.fillStyle = rgb(team_obj.color);
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = rgb([30, 30, 30]);
            ctx.stroke();
            if (this.type === BallType.FASTER) {
                ctx.beginPath();
                ctx.arc(this.pos[0], this.pos[1], this.radius * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgb(255,255,0)';
                ctx.fill();
            } else if (this.type === BallType.STRESSED) {
                ctx.beginPath();
                ctx.arc(this.pos[0], this.pos[1], this.radius * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgb(255,100,100)';
                ctx.fill();
            }
            ctx.font = FONT;
            ctx.fillStyle = 'rgb(255,255,255)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const value_text = this.format_text(this.value);
            ctx.fillText(value_text, this.pos[0], this.pos[1]);
        }
        format_text(value) {
            if (value > 1000000) return `${(value / 1000000).toFixed(1)}M`;
            if (value > 1000) return `${(value / 1000).toFixed(1)}K`;
            return Math.floor(value).toString();
        }
    }
    class Game {
        constructor() {
            this.teams = getTeamDefs(config.team_count).map(def => new TeamBase(...def));
            this.bullets = [];
            this.balls = [];
            this.running = true;
            this.frame_count = 0;
            this.console_input = '';
            this.console_active = false;
            this.message = '';
            this.message_time = 0;
            this.last_event_frame = 0;
            this.event_active = false;
            this.event_text = '';
            this.event_end_time = 0;
            this.territory_surface = document.createElement('canvas');
            this.territory_surface.width = SCREEN_WIDTH;
            this.territory_surface.height = SCREEN_HEIGHT;
            this.territory_ctx = this.territory_surface.getContext('2d');
            this.territory_grid = {};
            this.block_size = Math.floor(SINGLE_BLOCK_WIDTH * 5);
            this.init_territory();
            this.particles = [];
            this.damage_texts = [];
            this.start_time = performance.now();
            this.grid = new Map();
            this.cell_size = 100;
            this.profiler = new Profiler();
            this.max_workers = 4;
        }
        init_territory() {
            this.territory_ctx.fillStyle = rgb(BACKGROUND);
            this.territory_ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            this.territory_grid = {};
            for (let x = 0; x < SCREEN_WIDTH; x += this.block_size) {
                for (let y = 0; y < SCREEN_HEIGHT; y += this.block_size) {
                    const key = `${x}_${y}`;
                    this.territory_grid[key] = null;
                    this.territory_ctx.strokeStyle = rgb(NEUTRAL_COLOR);
                    this.territory_ctx.lineWidth = 1;
                    this.territory_ctx.strokeRect(x, y, this.block_size, this.block_size);
                }
            }
            for (let team of this.teams) {
                const grid_x = Math.floor(team.pos[0] / this.block_size) * this.block_size;
                const grid_y = Math.floor(team.pos[1] / this.block_size) * this.block_size;
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const x = grid_x + dx * this.block_size;
                        const y = grid_y + dy * this.block_size;
                        const key = `${x}_${y}`;
                        if (key in this.territory_grid) {
                            this.territory_grid[key] = team;
                            this.territory_ctx.fillStyle = rgb(team.color);
                            this.territory_ctx.fillRect(x, y, this.block_size, this.block_size);
                        }
                    }
                }
            }
        }
        build_spatial_grid() {
            this.grid = new Map();
            for (let ball of this.balls) {
                const cell_x = Math.floor(ball.pos[0] / this.cell_size);
                const cell_y = Math.floor(ball.pos[1] / this.cell_size);
                const key = `${cell_x}_${cell_y}`;
                if (!this.grid.has(key)) this.grid.set(key, []);
                this.grid.get(key).push(['ball', ball]);
            }
            for (let bullet of this.bullets) {
                const cell_x = Math.floor(bullet.pos[0] / this.cell_size);
                const cell_y = Math.floor(bullet.pos[1] / this.cell_size);
                const key = `${cell_x}_${cell_y}`;
                if (!this.grid.has(key)) this.grid.set(key, []);
                this.grid.get(key).push(['bullet', bullet]);
            }
        }
        get_nearby_entities(pos) {
            const cell_x = Math.floor(pos[0] / this.cell_size);
            const cell_y = Math.floor(pos[1] / this.cell_size);
            let nearby = [];
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const key = `${cell_x + dx}_${cell_y + dy}`;
                    if (this.grid.has(key)) nearby = nearby.concat(this.grid.get(key));
                }
            }
            return nearby;
        }
        get_territory_owner(pos) {
            const grid_x = Math.floor(pos[0] / this.block_size) * this.block_size;
            const grid_y = Math.floor(pos[1] / this.block_size) * this.block_size;
            const key = `${grid_x}_${grid_y}`;
            return this.territory_grid[key] || null;
        }
        update_territory() {
            const territory_count = {};
            this.teams.forEach(team => territory_count[team] = 0);
            territory_count[null] = 0;
            const total_blocks = Object.keys(this.territory_grid).length;
            if (total_blocks === 0) return;
            for (let key in this.territory_grid) {
                const owner = this.territory_grid[key];
                territory_count[owner] += 1;
            }
            this.teams.forEach(team => {
                team.territory = Math.round(territory_count[team] / total_blocks * 100 * 10) / 10;
            });
        }
        claim_territory_at_point(pos, team) {
            const grid_x = Math.floor(pos[0] / this.block_size) * this.block_size;
            const grid_y = Math.floor(pos[1] / this.block_size) * this.block_size;
            const key = `${grid_x}_${grid_y}`;
            if (!(key in this.territory_grid)) return 0;
            const current_owner = this.territory_grid[key];
            if (current_owner === team) return 0;
            const cost = current_owner === null ? TERRITORY_CLAIM_COST[0] : TERRITORY_CLAIM_COST[1];
            this.territory_grid[key] = team;
            let team_obj = null;
            for (let i = 0; i < this.teams.length; i++) {
                if (this.teams[i].name === team) {
                    team_obj = this.teams[i];
                    break;
                }
            }
            this.territory_ctx.fillStyle = rgb(team_obj.color);
            this.territory_ctx.fillRect(grid_x, grid_y, this.block_size, this.block_size);
            return cost;
        }
        claim_territory_along_line(start_pos, end_pos, team, width) {
            const dx = end_pos[0] - start_pos[0];
            const dy = end_pos[1] - start_pos[1];
            const distance = Math.sqrt(dx * dx + dy * dy);
            let cost = 0;
            if (distance === 0) {
                cost += this.claim_territory_at_point(start_pos, team);
                return cost;
            }
            const ux = dx / distance;
            const uy = dy / distance;
            const vx = -uy;
            const vy = ux;
            const steps = Math.floor(distance) + 1;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const center_x = start_pos[0] + dx * t;
                const center_y = start_pos[1] + dy * t;
                for (let j = Math.floor(-width / 2 - 1); j <= Math.floor(width / 2 + 1); j++) {
                    const offset_x = vx * j;
                    const offset_y = vy * j;
                    const x = center_x + offset_x;
                    const y = center_y + offset_y;
                    cost += this.claim_territory_at_point([x, y], team);
                }
            }
            return cost;
        }
        clear_map() {
            this.init_territory();
            this.show_message("地图已重置!");
        }
        add_bullet_to_queue(team, bullet_type, amount, value) {
            team.add_bullets(amount, bullet_type, value);
        }
        fire_bullets(team) {
            return team.fire_from_queue();
        }
        add_ball(team, ball_type, value, pos = null, angle = null) {
            if (pos === null) {
                const offset_x = 40 * Math.cos(team.angle * Math.PI / 180);
                const offset_y = 40 * Math.sin(team.angle * Math.PI / 180);
                pos = [team.pos[0] + offset_x, team.pos[1] + offset_y];
            }
            if (angle === null) angle = team.angle;
            this.balls.push(new Ball(team, ball_type, value, pos, angle));
        }
        trigger_random_event() {
            const active_teams = this.teams.filter(team => team.active);
            if (active_teams.length === 0) return;
            const team = active_teams[Math.floor(Math.random() * active_teams.length)];
            const event_type = ['shield', 'bullets', 'ball'][Math.floor(Math.random() * 3)];
            const reward_level = weighted_random(config.event_rewards.length, config.reward_weights);
            const reward = config.event_rewards[reward_level];
            if (event_type === 'shield') {
                team.shield += reward;
                this.event_text = `${team.name} 获得护盾 +${this.format_number(reward)}!`;
            } else if (event_type === 'bullets') {
                const bullet_types = [BulletType.NORMAL, BulletType.SPREADING, BulletType.ROTATING, BulletType.SHOT, BulletType.LASER, BulletType.SPLITTING];
                team.add_bullets(reward, bullet_types[Math.floor(Math.random() * bullet_types.length)], 1);
                this.event_text = `${team.name} 获得子弹 +${this.format_number(reward)}!`;
            } else if (event_type === 'ball') {
                const ball_value = Math.min(reward, 10000000);
                this.add_ball(team, BallType[Object.keys(BallType)[Math.floor(Math.random() * 3)]], ball_value);
                this.event_text = `${team.name} 获得价值 ${this.format_number(ball_value)} 的球体!`;
            }
            this.event_active = true;
            this.event_end_time = performance.now() + 3000;
        }
        format_number(num) {
            if (num >= 1000000000) return `${(num / 1000000000).toFixed(1)}B`;
            if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
            if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
            return num.toString();
        }
        process_command(command) {
            const parts = command.trim().split(/\s+/);
            if (parts.length === 0) return;
            const cmd = parts[0].toLowerCase();
            if (cmd === '/bullet' && parts.length >= 5) {
                const team_idx = parseInt(parts[1]);
                const amount = parseInt(parts[2]);
                const b_type = BulletType[parts[3].toUpperCase()];
                const value = parseInt(parts[4]);
                if (!isNaN(team_idx) && team_idx >= 0 && team_idx < this.teams.length && b_type) {
                    this.add_bullet_to_queue(this.teams[team_idx], b_type, amount, value);
                    this.show_message(`已为${this.teams[team_idx].name}添加子弹到队列`);
                } else {
                    this.show_message("错误: 无效的子弹命令格式");
                }
            } else if (cmd === '/ball' && parts.length >= 5) {
                const team_idx = parseInt(parts[1]);
                const amount = parseInt(parts[2]);
                const b_type = BallType[parts[3].toUpperCase()];
                const value = parseInt(parts[4]);
                if (!isNaN(team_idx) && team_idx >= 0 && team_idx < this.teams.length && b_type) {
                    for (let i = 0; i < amount; i++) {
                        this.add_ball(this.teams[team_idx], b_type, value);
                    }
                    this.show_message(`已为${this.teams[team_idx].name}添加${amount}个球体`);
                } else {
                    this.show_message("错误: 无效的球体命令格式");
                }
            } else if (cmd === '/clear_map') {
                this.clear_map();
            } else if (cmd === '/tick') {
                const tick = parseInt(parts[1]);
                if (!isNaN(tick)) TICKING = tick;
                else this.show_message("错误：数值错误");
            } else if (cmd === '/help') {
                this.show_message("可用命令: /bullet [队伍] [数量] [类型] [价值], /ball [队伍] [数量] [类型] [价值], /clear_map");
            } else {
                this.show_message("错误: 未知命令");
            }
        }
        show_message(msg) {
            this.message = msg;
            this.message_time = performance.now();
        }
        update() {
            this.frame_count += 1;
            this.profiler.start_section("clear_map");
            if (CLEAR_MAP_FRAME > 0 && this.frame_count % CLEAR_MAP_FRAME === 0) this.clear_map();
            this.profiler.end_section();
            if (this.frame_count - this.last_event_frame > config.event_min_frames) {
                if (Math.random() < config.event_prob) {
                    this.trigger_random_event();
                    this.last_event_frame = this.frame_count;
                }
            }
            if (this.event_active && performance.now() > this.event_end_time) this.event_active = false;
            this.profiler.start_section("update_particles");
            this.particles = this.particles.filter(p => !p.update());
            if (this.particles.length > 500) this.particles = this.particles.slice(-500);
            this.profiler.end_section();
            this.profiler.start_section("update_damage_text");
            this.damage_texts = this.damage_texts.filter(t => !t.update());
            if (this.damage_texts.length > 200) this.damage_texts = this.damage_texts.slice(-200);
            this.profiler.end_section();
            this.profiler.start_section("update_team");
            const enemies = [...this.balls, ...this.bullets];
            for (let team of this.teams) {
                if (team.active) {
                    team.update_turret(enemies);
                    const new_bullets = this.fire_bullets(team);
                    this.bullets.push(...new_bullets);
                } else if (team.death_time > 0 && performance.now() - team.death_time > REVIVAL_TIME) {
                    for (let i = 0; i < this.bullets.length; i++) {
                        const bullet = this.bullets[i];
                        if (bullet.team === team && bullet.value >= REVIVAL_COST) {
                            const [extra_balls, cost] = team.try_revive(bullet.value);
                            if (extra_balls > 0) {
                                this.bullets.splice(i, 1);
                                let ball_value = REVIVAL_COST;
                                for (let j = 0; j < extra_balls; j++) {
                                    this.add_ball(team, BallType.NORMAL, ball_value);
                                    ball_value *= 2;
                                }
                                this.show_message(`${team.name} 已复活!`);
                                break;
                            }
                        }
                    }
                }
            }
            this.profiler.end_section();
            this.profiler.start_section("build_spatial_grid");
            this.build_spatial_grid();
            this.profiler.end_section();
            this.profiler.start_section("update_bullets");
            const bullets_to_remove = [];
            let new_bullets = [];
            const split_angles = Array.from({length: SPLITTING_COUNT}, () => Math.random() * 90 - 45);
            const active_enemy_teams = this.teams.filter(t => t.active);
            for (let bullet of this.bullets) {
                bullet.update(this);
                if (bullet.type === BulletType.SPLITTING && bullet.split) {
                    bullets_to_remove.push(bullet);
                    for (let angle of split_angles) {
                        const new_b = new Bullet(bullet.team, BulletType.SPLITTING, Math.floor(bullet.value / SPLITTING_COUNT), [...bullet.pos], bullet.angle + angle);
                        new_bullets.push(new_b);
                    }
                    continue;
                }
                const nearby = this.get_nearby_entities(bullet.pos);
                for (let [etype, entity] of nearby) {
                    if (etype === 'ball' && bullet._collide(entity)) {
                        if (bullet.team === entity.team) {
                            entity.value += bullet.value;
                            bullet.value = 0;
                        } else {
                            bullet.handle_collision_with_ball(entity, this);
                        }
                        if (bullet.value <= 0) bullets_to_remove.push(bullet);
                    }
                }
                for (let team of active_enemy_teams) {
                    if (team === bullet.team) continue;
                    if (bullet.handle_collision_with_base(team, this)) bullets_to_remove.push(bullet);
                }
                if (bullet.should_remove()) bullets_to_remove.push(bullet);
            }
            this.bullets = this.bullets.filter(b => !bullets_to_remove.includes(b));
            this.bullets.push(...new_bullets);
            this.profiler.end_section();
            this.profiler.start_section("update_balls");
            const balls_to_remove = [];
            for (let ball of this.balls) {
                ball.update(this);
                if (ball.value <= 0) {
                    balls_to_remove.push(ball);
                    continue;
                }
                const nearby = this.get_nearby_entities(ball.pos);
                for (let [etype, entity] of nearby) {
                    if (etype === 'ball' && entity !== ball && ball.team !== entity.team && ball._collide(entity)) {
                        ball.handle_collision_with_ball(entity, this);
                        ball.radius = ball.calculate_radius();
                        entity.radius = entity.calculate_radius();
                    }
                }
                for (let team of active_enemy_teams) {
                    if (team === ball.team) continue;
                    ball.handle_collision_with_base(team, this);
                }
                if (ball.type === BallType.STRESSED && ball.value > 0) {
                    for (let [etype, entity] of nearby) {
                        if (etype === 'bullet' && entity.team !== ball.team) {
                            const dist = Math.sqrt((entity.pos[0] - ball.pos[0])**2 + (entity.pos[1] - ball.pos[1])**2);
                            if (dist < ATTRACTION_RADIUS) {
                                const dx = ball.pos[0] - entity.pos[0];
                                const dy = ball.pos[1] - entity.pos[1];
                                entity.angle = Math.atan2(dy, dx) * 180 / Math.PI;
                            }
                        } else if (etype === 'ball' && entity.team !== ball.team) {
                            const dist = Math.sqrt((entity.pos[0] - ball.pos[0])**2 + (entity.pos[1] - ball.pos[1])**2);
                            if (dist < ATTRACTION_RADIUS) {
                                const dx = ball.pos[0] - entity.pos[0];
                                const dy = ball.pos[1] - entity.pos[1];
                                entity.angle = Math.atan2(dy, dx) * 180 / Math.PI;
                            }
                        }
                    }
                }
            }
            this.balls = this.balls.filter(b => !balls_to_remove.includes(b));
            this.profiler.end_section();
            this.profiler.start_section("update_territory");
            if (this.frame_count % 30 === 0) this.update_territory();
            this.profiler.end_section();
            const active_teams = this.teams.filter(team => team.active);
            if (active_teams.length === 1) {
                this.running = false;
                this.show_message(`游戏结束! ${active_teams[0].name} 获胜!`);
            }
        }
        draw() {
            ctx.fillStyle = rgb(BACKGROUND);
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            this.profiler.start_section("draw_territory");
            ctx.drawImage(this.territory_surface, 0, 0);
            this.profiler.end_section();
            this.profiler.start_section("draw_ball");
            for (let ball of this.balls) ball.draw(ctx);
            this.profiler.end_section();
            this.profiler.start_section("draw_bullet");
            for (let bullet of this.bullets) bullet.draw(ctx);
            this.profiler.end_section();
            this.profiler.start_section("draw_team");
            for (let team of this.teams) {
                if (team.active || team.death_time > 0) team.draw(ctx);
            }
            this.profiler.end_section();
            this.profiler.start_section("draw_particle");
            for (let particle of this.particles) particle.draw(ctx);
            this.profiler.end_section();
            this.profiler.start_section("draw_damage_text");
            for (let text of this.damage_texts) text.draw(ctx);
            this.profiler.end_section();
            if (this.console_active) {
                ctx.fillStyle = 'rgb(30,30,40)';
                ctx.fillRect(10, SCREEN_HEIGHT - 40, SCREEN_WIDTH - 20, 30);
                ctx.font = FONT;
                ctx.fillStyle = 'rgb(200,200,200)';
                ctx.textBaseline = 'top';
                ctx.fillText(`> ${this.console_input}`, 20, SCREEN_HEIGHT - 35);
            }
            if (performance.now() - this.message_time < 3000) {
                ctx.font = FONT;
                ctx.fillStyle = 'rgb(255,255,0)';
                ctx.textAlign = 'center';
                ctx.fillText(this.message, SCREEN_WIDTH / 2, 20);
            }
            if (this.event_active) {
                ctx.font = LARGE_FONT;
                ctx.fillStyle = 'rgb(0,255,255)';
                ctx.textAlign = 'center';
                ctx.fillText(this.event_text, SCREEN_WIDTH / 2, 60);
            }
            ctx.font = LARGE_FONT;
            ctx.fillStyle = 'rgb(200,200,255)';
            ctx.textAlign = 'center';
            ctx.fillText("球体战争 - 优化版", SCREEN_WIDTH / 2, 5);
            const game_time = Math.floor((performance.now() - this.start_time) / 1000);
            const time_text = `游戏时间: ${Math.floor(game_time / 60)}:${(game_time % 60).toString().padStart(2, '0')}`;
            ctx.font = FONT;
            ctx.fillStyle = 'rgb(180,180,200)';
            const time_width = ctx.measureText(time_text).width;
            ctx.fillText(time_text, SCREEN_WIDTH - time_width - 10, 10);
            if (!this.console_active) {
                const help_text = "按T打开控制台, /help查看命令";
                const help_width = ctx.measureText(help_text).width;
                ctx.fillStyle = 'rgb(150,150,180)';
                ctx.fillText(help_text, SCREEN_WIDTH - help_width - 10, SCREEN_HEIGHT - 70);
            }
            this.draw_performance_info(ctx);
        }
        draw_performance_info(ctx) {
            let y = SCREEN_HEIGHT - 300;
            const [fps, duration] = this.profiler.get_fps();
            const fps_text = `FPS: ${fps.toFixed(1)} (Duration: ${duration.toFixed(3)})`;
            ctx.font = SMALL_FONT;
            ctx.fillStyle = 'rgb(255,255,0)';
            ctx.textAlign = 'left';
            ctx.fillText(fps_text, 10, y);
            y += 30;
            const stats = this.profiler.get_stats();
            for (let stat of stats) {
                const [name, avg, min_val, max_val] = stat;
                const text = `${name}: ${avg}, ${max_val}`;
                ctx.fillStyle = 'rgb(255,255,255)';
                ctx.fillText(text, 10, y);
                y += 20;
            }
        }
    }
    // Initialize and run the game
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let game = new Game();
    let animationId;
    function loop() {
        game.profiler.frame_end();
        if (!game.running) {
            cancelAnimationFrame(animationId);
            draw_end_screen();
            return;
        }
        game.update();
        game.draw();
        animationId = requestAnimationFrame(loop);
    }
    function draw_end_screen() {
        ctx.fillStyle = 'rgb(20,20,30)';
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
        const winner = game.teams.find(t => t.active);
        if (winner) {
            ctx.font = LARGE_FONT;
            ctx.fillStyle = rgb(winner.color);
            ctx.textAlign = 'center';
            ctx.fillText(`${winner.name} 获胜!`, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 50);
        }
        ctx.font = FONT;
        ctx.fillStyle = 'rgb(200,200,200)';
        ctx.fillText("按R重新开始, 按ESC退出", SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 20);
    }
    document.addEventListener('keydown', (e) => {
        if (game.console_active) {
            if (e.key === 'Enter') {
                game.process_command(game.console_input);
                game.console_input = '';
            } else if (e.key === 'Backspace') {
                game.console_input = game.console_input.slice(0, -1);
            } else if (e.key === 'Escape') {
                game.console_active = false;
                game.console_input = '';
            } else if (e.key.length === 1) {
                game.console_input += e.key;
            }
        } else {
            if (e.key.toLowerCase() === 't') {
                game.console_active = true;
            } else if (e.key.toLowerCase() === 'c') {
                game.clear_map();
            } else if (e.key === 'Escape') {
                game.running = false;
            }
        }
        if (!game.running && e.key.toLowerCase() === 'r') {
            game = new Game();
            requestAnimationFrame(loop);
        }
    });
    function applyConfig() {
        config.event_min_frames = parseInt(document.getElementById('event_min_frames').value) || 100;
        config.event_prob = parseFloat(document.getElementById('event_prob').value) || 0.1;
        config.event_rewards = document.getElementById('rewards').value.split(',').map(n => parseInt(n.trim()) || 0).filter(n => n > 0);
        config.reward_weights = document.getElementById('weights').value.split(',').map(w => parseFloat(w.trim()) || 0).filter(w => w > 0);
        config.team_count = parseInt(document.getElementById('team_count').value) || 4;
        game.running = false;
        cancelAnimationFrame(animationId);
        game = new Game();
        requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
</script>
</body>
</html>
